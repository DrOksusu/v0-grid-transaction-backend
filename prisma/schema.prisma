generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                Int                @id @default(autoincrement())
  email             String             @unique
  name              String?
  password          String
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  nickname          String?
  bots              Bot[]
  credentials       Credential[]
  infiniteBuyStocks InfiniteBuyStock[]
  monthlyProfits    MonthlyProfit[]
  passwordResets    PasswordReset[]
  profitSnapshots   ProfitSnapshot[]
  pushSubscriptions PushSubscription[]
  subscription      Subscription?
  upbitDonations    UpbitDonation[]
  usdtDeposits      UsdtDeposit[]
  usdtPayments      UsdtPayment[]

  @@map("users")
}

model PasswordReset {
  id        Int       @id @default(autoincrement())
  userId    Int
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("password_resets")
}

model Bot {
  id                 Int         @id @default(autoincrement())
  userId             Int
  exchange           Exchange
  ticker             String
  lowerPrice         Float
  upperPrice         Float
  priceChangePercent Float
  gridCount          Int
  orderAmount        Float
  stopAtMax          Boolean     @default(false)
  status             BotStatus   @default(stopped)
  investmentAmount   Float       @default(0)
  currentProfit      Float       @default(0)
  totalTrades        Int         @default(0)
  lastExecutedAt     DateTime?
  errorMessage       String?     @db.Text
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  deletedAt          DateTime?
  user               User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  gridLevels         GridLevel[]
  trades             Trade[]

  @@index([userId])
  @@index([status])
  @@index([userId, status])
  @@index([deletedAt])
  @@map("bots")
}

model GridLevel {
  id        Int             @id @default(autoincrement())
  botId     Int
  price     Float
  type      TradeType
  status    GridLevelStatus @default(available)
  orderId   String?
  filledAt  DateTime?
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  buyPrice  Float?
  sellPrice Float?
  bot       Bot             @relation(fields: [botId], references: [id], onDelete: Cascade)
  trades    Trade[]

  @@index([botId])
  @@index([botId, status])
  @@index([status])
  @@index([botId, type, status, price], map: "idx_grid_levels_botId_type_status_price")
  @@index([orderId], map: "idx_grid_levels_orderId")
  @@map("grid_levels")
}

model Trade {
  id          Int         @id @default(autoincrement())
  botId       Int
  gridLevelId Int?
  type        TradeType
  price       Float
  amount      Float
  total       Float
  profit      Float?
  orderId     String
  executedAt  DateTime    @default(now())
  createdAt   DateTime    @default(now())
  filledAt    DateTime?
  status      TradeStatus @default(pending)
  exchange    String?
  ticker      String?
  bot         Bot         @relation(fields: [botId], references: [id])
  gridLevel   GridLevel?  @relation(fields: [gridLevelId], references: [id])

  @@index([botId])
  @@index([botId, status])
  @@index([gridLevelId])
  @@index([botId, status, filledAt], map: "idx_trades_botId_status_filledAt")
  @@index([orderId], map: "idx_trades_orderId")
  @@index([ticker])
  @@map("trades")
}

model Credential {
  id              Int               @id @default(autoincrement())
  userId          Int
  exchange        Exchange
  apiKey          String            @db.Text
  secretKey       String            @db.Text
  ipWhitelist     String?
  ipRestricted    Boolean           @default(false)
  isValid         Boolean           @default(false)
  lastValidatedAt DateTime?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  accessToken     String?           @db.Text
  accountNo       String?
  isPaper         Boolean           @default(true)
  tokenExpireAt   DateTime?
  purpose         CredentialPurpose @default(default)
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, exchange, purpose])
  @@index([userId])
  @@index([userId, exchange])
  @@map("credentials")
}

model InfiniteBuyStock {
  id               Int                 @id @default(autoincrement())
  userId           Int
  ticker           String
  name             String
  exchange         String              @default("NAS")
  buyAmount        Float
  totalRounds      Int                 @default(40)
  targetProfit     Float               @default(10)
  status           InfiniteBuyStatus   @default(buying)
  currentRound     Int                 @default(0)
  totalInvested    Float               @default(0)
  totalQuantity    Float               @default(0)
  avgPrice         Float               @default(0)
  autoEnabled      Boolean             @default(true)
  buyTime          String?
  buyCondition     String              @default("daily")
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  completedAt      DateTime?
  strategy         InfiniteBuyStrategy @default(basic)
  accountNo        String              @default("")
  vrBandPercent    Float?              @default(15)
  vrCycleStartDate DateTime?
  vrCycleWeeks     Int?                @default(2)
  vrDepositAmount  Float?
  vrGradient       Int?                @default(10)
  vrLastCycleDate  DateTime?
  vrPool           Float?
  vrStyle          String?
  vrValue          Float?
  buyRecords       InfiniteBuyRecord[]
  user             User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, accountNo])
  @@index([userId, accountNo, ticker])
  @@index([status])
  @@map("infinite_buy_stocks")
}

model InfiniteBuyRecord {
  id            Int              @id @default(autoincrement())
  stockId       Int
  type          TradeType
  round         Int?
  price         Float
  quantity      Float
  amount        Float
  profit        Float?
  profitPercent Float?
  orderId       String?
  orderStatus   String           @default("pending")
  executedAt    DateTime         @default(now())
  filledAt      DateTime?
  orderType     String           @default("market")
  targetPrice   Float?
  orderSubType  String?
  vrOrderIndex  Int?
  vrTargetBand  String?
  stock         InfiniteBuyStock @relation(fields: [stockId], references: [id], onDelete: Cascade)

  @@index([stockId])
  @@index([type])
  @@map("infinite_buy_records")
}

model MonthlyProfit {
  id          Int      @id @default(autoincrement())
  userId      Int
  exchange    Exchange
  month       String
  totalProfit Float    @default(0)
  tradeCount  Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, exchange, month])
  @@index([userId])
  @@index([month])
  @@map("monthly_profits")
}

model ProfitSnapshot {
  id               Int      @id @default(autoincrement())
  userId           Int
  exchange         Exchange
  ticker           String
  botType          String   @default("grid")
  finalProfit      Float
  totalTrades      Int
  investmentAmount Float
  profitPercent    Float
  startedAt        DateTime
  deletedAt        DateTime @default(now())
  runningDays      Int
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([deletedAt])
  @@map("profit_snapshots")
}

model SchedulerLog {
  id           Int                @id @default(autoincrement())
  type         SchedulerLogType
  status       SchedulerLogStatus
  stockId      Int?
  ticker       String?
  message      String             @db.Text
  details      String?            @db.Text
  errorMessage String?            @db.Text
  executedAt   DateTime           @default(now())

  @@index([type])
  @@index([status])
  @@index([executedAt])
  @@index([stockId])
  @@map("scheduler_logs")
}

model Subscription {
  id                   Int            @id @default(autoincrement())
  userId               Int            @unique
  plan                 PlanType       @default(free)
  status               String         @default("active")
  paymentMethod        PaymentMethod?
  stripeCustomerId     String?
  stripeSubscriptionId String?
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean        @default(false)
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt
  user                 User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([plan])
  @@map("subscriptions")
}

model UsdtDeposit {
  id              Int       @id @default(autoincrement())
  userId          Int
  address         String
  uniqueCode      String
  expectedAmount  Float
  status          String    @default("pending")
  txHash          String?
  confirmedAmount Float?
  confirmedAt     DateTime?
  expiresAt       DateTime
  createdAt       DateTime  @default(now())
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([uniqueCode, status])
  @@map("usdt_deposits")
}

model UsdtPayment {
  id          Int      @id @default(autoincrement())
  userId      Int
  txHash      String
  fromAddress String
  amount      Float
  periodStart DateTime
  periodEnd   DateTime
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([txHash])
  @@map("usdt_payments")
}

model UpbitDonation {
  id              Int              @id @default(autoincrement())
  userId          Int
  currency        DonationCurrency
  expectedAmount  Float
  status          DonationStatus   @default(pending)
  txId            String?
  confirmedAmount Float?
  confirmedAt     DateTime?
  periodStart     DateTime?
  periodEnd       DateTime?
  expiresAt       DateTime
  createdAt       DateTime         @default(now())
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([currency, status])
  @@index([expectedAmount, currency, status])
  @@map("upbit_donations")
}

model PushSubscription {
  id          Int      @id @default(autoincrement())
  userId      Int
  endpoint    String   @db.Text
  p256dh      String   @db.Text
  auth        String   @db.Text
  orderFilled Boolean  @default(true)
  priceAlert  Boolean  @default(true)
  dailyReport Boolean  @default(false)
  userAgent   String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscriptions")
}

model WhaleTransaction {
  id              Int                  @id @default(autoincrement())
  txId            String               @unique
  txHash          String
  blockchain      String
  symbol          String
  amount          Float
  amountUsd       Float
  fromAddress     String               @db.Text
  fromOwner       String
  fromOwnerType   String
  toAddress       String               @db.Text
  toOwner         String
  toOwnerType     String
  transactionType WhaleTransactionType
  signal          WhaleSignal
  timestamp       Int
  createdAt       DateTime             @default(now())

  @@index([symbol])
  @@index([timestamp])
  @@index([symbol, timestamp])
  @@map("whale_transactions")
}

enum Exchange {
  upbit
  binance
  kis
}

enum BotStatus {
  running
  stopped
  error
  deleting
}

enum GridLevelStatus {
  available
  pending
  filled
  inactive
}

enum TradeType {
  buy
  sell
}

enum TradeStatus {
  pending
  filled
  cancelled
}

enum CredentialPurpose {
  default
  infinite_buy
  vr
}

enum InfiniteBuyStatus {
  buying
  completed
  stopped
}

enum InfiniteBuyStrategy {
  basic
  strategy1
  vr
}

enum SchedulerLogType {
  auto_buy
  strategy1_buy
  vr_cycle
  vr_order
  price_check
  order_check
}

enum SchedulerLogStatus {
  started
  completed
  skipped
  error
}

enum PlanType {
  free
  pro
  premium
}

enum PaymentMethod {
  stripe
  usdt
}

enum DonationCurrency {
  KRW
  USDT
}

enum DonationStatus {
  pending
  confirmed
  expired
}

enum WhaleTransactionType {
  exchange_to_wallet
  wallet_to_exchange
  exchange_to_exchange
  wallet_to_wallet
  unknown
}

enum WhaleSignal {
  bullish
  bearish
  neutral
}
